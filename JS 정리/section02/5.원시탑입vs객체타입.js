// 원시타입 VS 객체 타입

// 원시 타입 (= 불변값)
// : Number, String, Boolean 등...
// => "값 자체"로써 변수에 저장되고 복사된다.
// => 재할당을 해도 실제 메모리의 값은 수정되지 않는다.💡
//   => 실제 원본 데이터의 값은 변경되지 않는다.

let p1 = 1;
let p2 = p1;

p2 = 2;             // p1 = 1, p2 = 2

// 객체 타입 (= 가변값)
// : Object, Array, Function 등...
// => "참조값"을 통해 변수에 저장되고 복사된다.
// => 메모리 상의 원본 데이터를 수정한다.💡

// 얕은 복사 (위험⚠️)
let o1 = { name: "콩두부" };
let o2 = o1;

o2.name = "순두부";     // o1 = 콩두부, o2 = 순두부

// [주의사항]
// 1. 의도치 않게 값이 수정될 수 있다.
// =>💡새로운 객체를 생성하면서 spread 연산자로 프로퍼티만 따로 복사해서 사용한다.
//    =>💡다른 참조값을 갖게 된다.

// 깊은 복사(안전✨)
let a1 = { name: "여름" };
let a2 = { ...a1 };

o2.name = "봄";     // a1 = 여름, a2 = 봄

// 2. 객체간의 비교는 기본적으로 "참조값"을 기준으로 이루어진다. 
let b1 = { name: "콩두부" };
let b2 = 1;
let b3 = { ...b1 };

// 얕은 비교
console.log(b1 === b2);     // true
console.log(b1 === b3);     // false

//💡 JSON.stringify (자바스크립트 내장함수) 💡
// => 참조값이 아니라 "프로퍼티 값"으로 비교를 하고 싶다면?

// 깊은 비교
console.log(
    JSON.stringity(b1) === JSON.stringify(b3)
);
// True

//3. 배열과 함수도 사실 객체이다.